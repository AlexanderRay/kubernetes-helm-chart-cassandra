kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ template "kubernetes.name" . }}
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ template "kubernetes.name" . }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
data:
  run_override.sh: |-
    #/bin/sh

    export CLUSTER_DOMAIN=$(hostname -d | awk -F"." '{print $(NF-1),".",$NF}' | sed 's/ //g')
    export CASSANDRA_SEEDS={{ template "kubernetes.name" . }}-0.{{ template "kubernetes.name" . }}.{{ .Release.Namespace }}.svc.$CLUSTER_DOMAIN,{{ template "kubernetes.name" . }}-1.{{ template "kubernetes.name" . }}.{{ .Release.Namespace }}.svc.$CLUSTER_DOMAIN

    /run.sh
  postStart.sh: |-
    #!/bin/sh

    until /ready-probe.sh ; do
      echo "Waiting node to be ready"
      sleep 1
    done

    nohup /usr/local/apache-cassandra/scripts/repair.sh &
    exit 0
  preStop.sh: |-
    #!/bin/sh

    run_nodetool() {
      echo "Running: nodetool $1"
      /usr/local/apache-cassandra/bin/nodetool $1
      sleep 5
    }

    while [ $(/usr/local/apache-cassandra/bin/nodetool status | awk "/$CASSANDRA_RACK/{ print \$1,\$2 }" | grep -v $POD_IP | awk '{ print $1 }' | grep -v UN) -eq 0 ] ; do
      echo "Waiting all nodes to recover a correct status before draining this node"
      sleep 5
      pidof java || exit 1
    done

    run_nodetool disablethrift
    run_nodetool disablebinary
    run_nodetool disablegossip
    run_nodetool flush
    run_nodetool drain
    sleep 10
    run_nodetool stop
    run_nodetool stopdaemon

    exit 0
  repair.sh: |-
    while [ $(/usr/local/apache-cassandra/bin/nodetool status | grep '^UN' | wc -l) -ne {{ .Values.cassandraReplicaCount }} ] ; then
      sleep 10
    fi
    sleep $[ ( $RANDOM % 1800 )  + 1 ]s
    /usr/local/apache-cassandra/bin/nodetool repair
  snapshot2s3.sh: |-
    #!/bin/bash

    function alert_failure() {
      content=$1
      file="${CASSANDRA_CLUSTER_NAME}_$(hostname)"
      resource="/$AWS_BUCKET/failures/${file}"
      contentType="text/plain"
      dateValue=`date -R`
      stringToSign="PUT\n\n${contentType}\n${dateValue}\n${resource}"
      signature=`echo -en ${stringToSign} | openssl sha1 -hmac ${AWS_SECRET_ACCESS_KEY} -binary | base64`

      echo -e ${content} >> $file
      curl -X PUT -T "${file}" \
        -H "Host: ${AWS_BUCKET}.s3.amazonaws.com" \
        -H "Date: ${dateValue}" \
        -H "Content-Type: ${contentType}" \
        -H "Authorization: AWS ${AWS_ACCESS_KEY_ID}:${signature}" \
        https://${AWS_BUCKET}.s3-eu-west-1.amazonaws.com/failures/${file}
      rm -f $file
    }

    function clean() {
      echo "[+] Cleaning"
      /usr/local/apache-cassandra/bin/nodetool clearsnapshot
      rm -Rf /snap /tmp/snapshot2s3.log
    }

    # Create lock or stop if already present
    function create_lock() {
      if [ -f /tmp/snapshot2s3.lock ] ; then
        echo "Backup or restore is already in progress for $CLUSTER_DOMAIN/$CASSANDRA_CLUSTER_NAME/$(hostname)"
        exit 0
      fi
    }

    function release_lock() {
      rm -Rf /tmp/snapshot2s3.lock
    }

    function backup() {

      create_lock
      clean

      export LC_ALL=C
      snap_name="snapshot_$(date +%Y-%m-%d_%H-%M-%S)"

      # Create snapshot
      echo "[+] Starting Snapshot"
      /usr/local/apache-cassandra/bin/nodetool snapshot -t $snap_name > /tmp/snapshot2s3.log 2>&1
      if [ $? != 0 ] ; then
        echo "Error during snapshot, please check manually, cleaning before exit"
        alert_failure "Error during snaptshot:\n$(cat /tmp/snapshot2s3.log)"
        /usr/local/apache-cassandra/bin/nodetool clearsnapshot
        exit 1
      fi
      cat /tmp/snapshot2s3.log

      # Create temporary folder
      find /var/lib/cassandra/data -name $snap_name -exec mkdir -p /snap/{} \;

      # Make snapshot symlinks
      cd /snap
      for i in $(find . -name $snap_name | sed 's/^.\///') ; do
        rmdir /snap/$i
        ln -s /$i /snap/$i
      done

      # Transfer with duplicity
      echo "[+] Running duplicity to transfer to AWS"
      duplicity {{ default "--archive-dir /var/lib/cassandra/.duplicity --allow-source-mismatch --s3-european-buckets --s3-use-new-style --copy-links --num-retries 3 --s3-use-multiprocessing --s3-multipart-chunk-size 100 --volsize 1024" .Values.cassandraBackup.duplicityOptions }} full . {{ .Values.cassandraBackup.awsDestinationPath }} > /tmp/snapshot2s3.log 2>&1
      if [ $? != 0 ] ; then
        echo "Error while backuping $CLUSTER_DOMAIN/$CASSANDRA_CLUSTER_NAME/$(hostname)"
        alert_failure "Error with duplicity\n$(cat /tmp/snapshot2s3.log)"
      fi
      cat /tmp/snapshot2s3.log

      # Clean snapshot
      clean
      release_lock
    }

    function restore() {
      create_lock

      echo "[+] Running duplicity to restore from AWS"
      duplicity {{ default "--archive-dir /var/lib/cassandra/.duplicity --allow-source-mismatch --s3-european-buckets --s3-use-new-style --copy-links --num-retries 3 --s3-use-multiprocessing --s3-multipart-chunk-size 100 --volsize 1024" .Values.cassandraBackup.duplicityOptions }} --time $RESTORE_TIME {{ .Values.cassandraBackup.awsDestinationPath }} {{ .Values.cassandraBackup.restoreFolder }} > /tmp/snapshot2s3.log 2>&1
      if [ $? != 0 ] ; then
        echo "Error while restoring $CLUSTER_DOMAIN/$CASSANDRA_CLUSTER_NAME/$(hostname)"
        alert_failure "Error with duplicity\n$(cat /tmp/snapshot2s3.log)"
      fi
      cat /tmp/snapshot2s3.log

      # Clean snapshot
      clean
      release_lock
    }

    function list() {
      duplicity {{ default "--archive-dir /var/lib/cassandra/.duplicity --allow-source-mismatch --s3-european-buckets --s3-use-new-style --copy-links --num-retries 3 --s3-use-multiprocessing --s3-multipart-chunk-size 100 --volsize 1024" .Values.cassandraBackup.duplicityOptions }} collection-status {{ .Values.cassandraBackup.awsDestinationPath }}
    }

    function help() {
      echo "Usage: $0 [backup|restore|list] AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_PASSPHRASE AWS_BUCKET [RESTORE_TIME]"
      exit 1
    }

    # Check number of args
    test "$#" -lt 5 && help

    export AWS_ACCESS_KEY_ID=$2
    export AWS_SECRET_ACCESS_KEY=$3
    export PASSPHRASE=$4
    export AWS_BUCKET=$5
    export RESTORE_TIME=$6
    export CLUSTER_DOMAIN=$(hostname -d | awk -F"." '{print $(NF-1),".",$NF}' | sed 's/ //g')

    if [ $1 == "backup" ] ; then
      backup
    elif [ $1 == "restore" ] ; then
      test "$#" -ne 6 && help
      restore
    elif [ $1 == "list" ] ; then
      list
    else
      echo "Don't know what to do, please look help at ./$0"
    fi